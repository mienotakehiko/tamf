theory IND_CPA_asymmetric_encryption_TMAF02 begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, pair/2, pk/1, snd/1
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2







rule (modulo E) Setup:
   [ Fr( ~key ) ]
  --[ OnlyOnce( ), Setup( ~key ) ]->
   [ !Sk( $A, ~key ), !Pk( $A, pk(~key) ) ]

rule (modulo E) Get_pk:
   [ !Pk( S, publickey ) ] --> [ Out( publickey ) ]

rule (modulo E) attackerkey:
   [ !Sk( $B, key ) ] --[ Oracle( $B ) ]-> [ Out( key ) ]

rule (modulo E) Attacker_make_message:
   [ Fr( m_ ) ] --> [ Out( <$B, m_> ), St_Oracle( m_ ) ]

rule (modulo E) Sender_encrypt:
   [ Fr( ~m ), !Pk( $A, ~key ), Fr( r ) ]
  --[
  Send( $A, aenc(<<$A, ~m>, r>, ~key) ), Secret( ~m ), Sender( $A ),
  Oracle( $B ), Role( 'Sender' ), Sender_send_plain( ~m )
  ]->
   [ Out( aenc(<<$A, ~m>, r>, ~key) ), St_ReceiveKey( ~m, ~key ) ]

rule (modulo E) Encrypt_Attacker:
   [
   !Pk( $A, ~key ), Fr( r ), In( <$B, m_> ), In( <$A, ~m> ), St_Oracle( m_ )
   ]
  --[
  Send( $B, aenc(<$B, m_>, ~key) ), Secret( m_ ), Oracle( $B ),
  Sender( $A ), Role( 'Oracle' ), Attacker_send_plain( m_ )
  ]->
   [
   Out( aenc(<diff(<$B, m_>, <$A, ~m>), r>, ~key) ),
   St_ReceiveKey_Oracle_plain( m_, ~key )
   ]

rule (modulo E) Ow_Secrecy:
   [
   St_ReceiveKey_Oracle_plain( m_, key_ ), In( aenc(<$B, m_>, key_) ),
   St_ReceiveKey( ~m, key ), In( aenc(<$A, ~m>, key) )
   ]
  --[ Notequalvalue( <~m, m_> ), Secretmessage( ~m ) ]->
   [ Out( m_ ) ]

restriction OnlyOnce [right]:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction OnlyOnce [left]:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma ow_value_notequal [right]:
  all-traces
  "∀ #i #j x.
    ((Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j x.
  (Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j) ∧ ¬(#i = #j)"
*/
simplify
solve( (#i < #j)  ∥ (#j < #i) )
  case case_1
  by solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i )
next
  case case_2
  by solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i )
qed

lemma ow_value_notequal [left]:
  all-traces
  "∀ #i #j x.
    ((Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j x.
  (Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j) ∧ ¬(#i = #j)"
*/
simplify
solve( (#i < #j)  ∥ (#j < #i) )
  case case_1
  by solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i )
next
  case case_2
  by solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i )
qed

lemma secret_sender_message [right]:
  all-traces
  "∀ n #i.
    ((Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)) ⇒
    ((¬(∃ #j. K( n ) @ #j)) ∨
     (∃ B #j. (Oracle( B ) @ #j) ∧ (Sender( B ) @ #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ n #i.
  (Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)
 ∧
  (∃ #j. (K( n ) @ #j)) ∧
  (∀ B #j. (Oracle( B ) @ #j) ∧ (Sender( B ) @ #i) ⇒ ⊥)"
*/
simplify
solve( Secret( n ) @ #i )
  case Encrypt_Attacker
  by solve( !Pk( $A, ~key ) ▶₀ #i )
next
  case Sender_encrypt
  by solve( !Pk( $A, ~key ) ▶₁ #i )
qed

lemma secret_sender_message [left]:
  all-traces
  "∀ n #i.
    ((Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)) ⇒
    ((¬(∃ #j. K( n ) @ #j)) ∨
     (∃ B #j. (Oracle( B ) @ #j) ∧ (Sender( B ) @ #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ n #i.
  (Secret( n ) @ #i) ∧ (Role( 'Sender' ) @ #i)
 ∧
  (∃ #j. (K( n ) @ #j)) ∧
  (∀ B #j. (Oracle( B ) @ #j) ∧ (Sender( B ) @ #i) ⇒ ⊥)"
*/
simplify
solve( Secret( n ) @ #i )
  case Encrypt_Attacker
  by solve( !Pk( $A, ~key ) ▶₀ #i )
next
  case Sender_encrypt
  by solve( !Pk( $A, ~key ) ▶₁ #i )
qed

lemma ow_m_secret [right]:
  all-traces "∀ m #i. (Secretmessage( m ) @ #i) ⇒ (¬(∃ #j. K( m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m #i. (Secretmessage( m ) @ #i) ∧ ∃ #j. (K( m ) @ #j)"
*/
simplify
by solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i )

lemma ow_m_secret [left]:
  all-traces "∀ m #i. (Secretmessage( m ) @ #i) ⇒ (¬(∃ #j. K( m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m #i. (Secretmessage( m ) @ #i) ∧ ∃ #j. (K( m ) @ #j)"
*/
simplify
by solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i )

diffLemma Observational_equivalence:
rule-equivalence
  case Rule_Attacker_make_message
  backward-search
    case LHS
    step( simplify )
    MIRRORED
  next
    case RHS
    step( simplify )
    MIRRORED
  qed
next
  case Rule_Destrd_0_adec
  backward-search
    case LHS
    step( simplify )
    step( solve( !KD( aenc(x, pk(x.1)) ) ▶₀ #i ) )
      case Attacker_make_message
      by step( contradiction /* impossible chain */ )
    next
      case Encrypt_Attacker
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    qed
  next
    case RHS
    step( simplify )
    step( solve( !KD( aenc(x, pk(x.1)) ) ▶₀ #i ) )
      case Attacker_make_message
      by step( contradiction /* impossible chain */ )
    next
      case Encrypt_Attacker
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    qed
  qed
next
  case Rule_Destrd_0_fst
  backward-search
    case LHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case Attacker_make_message
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( contradiction /* impossible chain */ )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        MIRRORED
      qed
    next
      case Encrypt_Attacker
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    qed
  next
    case RHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case Attacker_make_message
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( contradiction /* impossible chain */ )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        MIRRORED
      qed
    next
      case Encrypt_Attacker
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    qed
  qed
next
  case Rule_Destrd_0_snd
  backward-search
    case LHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case Attacker_make_message
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( contradiction /* impossible chain */ )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        MIRRORED
      qed
    next
      case Encrypt_Attacker
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    qed
  next
    case RHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case Attacker_make_message
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( contradiction /* impossible chain */ )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        MIRRORED
      qed
    next
      case Encrypt_Attacker
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      by step( solve( (#vl, 0) ~~> (#i, 0) ) )
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        by step( contradiction /* impossible chain */ )
      qed
    qed
  qed
next
  case Rule_Encrypt_Attacker
  backward-search
    case LHS
    step( simplify )
    by step( solve( !Pk( $A, ~key ) ▶₀ #i ) )
  next
    case RHS
    step( simplify )
    by step( solve( !Pk( $A, ~key ) ▶₀ #i ) )
  qed
next
  case Rule_Equality
  backward-search
    case LHS
    step( simplify )
    step( solve( !KD( x ) ▶₁ #i ) )
      case Attacker_make_message
      step( solve( (#vl, 0) ~~> (#i, 1) ) )
        case d_0_fst
        step( solve( (#vr.1, 0) ~~> (#i, 1) ) )
          case Var_pub_B
          step( solve( !KU( $B ) @ #vk ) )
            case coerce
            step( solve( !KD( $B ) ▶₀ #vk ) )
              case Attacker_make_message
              by step( contradiction /* impossible chain */ )
            next
              case Encrypt_Attacker
              by step( solve( (#vl.1, 0) ~~> (#vk, 0) ) )
            next
              case Get_pk
              step( solve( !Pk( S, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            next
              case Ow_Secrecy
              by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr.2 ) )
            next
              case Sender_encrypt
              by step( contradiction /* impossible chain */ )
            next
              case attackerkey
              step( solve( !Sk( $B.1, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case pub
            MIRRORED
          qed
        qed
      next
        case d_0_snd
        step( solve( (#vr.1, 0) ~~> (#i, 1) ) )
          case Var_fresh_n
          step( solve( !KU( ~n ) @ #vk ) )
            case Attacker_make_message
            MIRRORED
          qed
        qed
      next
        case pair
        step( solve( !KU( ~n ) @ #vk.2 ) )
          case Attacker_make_message
          step( solve( !KU( $B ) @ #vk.2 ) )
            case coerce
            step( solve( !KD( $B ) ▶₀ #vk.2 ) )
              case Attacker_make_message
              by step( contradiction /* impossible chain */ )
            next
              case Encrypt_Attacker
              by step( solve( (#vl.1, 0) ~~> (#vk.2, 0) ) )
            next
              case Get_pk
              step( solve( !Pk( S, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            next
              case Ow_Secrecy
              by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr.2 ) )
            next
              case Sender_encrypt
              by step( contradiction /* impossible chain */ )
            next
              case attackerkey
              step( solve( !Sk( $B.1, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case pub
            MIRRORED
          qed
        qed
      qed
    next
      case Encrypt_Attacker
      step( solve( (#vl, 0) ~~> (#i, 1) ) )
        case aenc
        by step( solve( !Pk( $A, ~key ) ▶₀ #vr ) )
      qed
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        step( solve( (#vl, 0) ~~> (#i, 1) ) )
          case pk
          step( solve( !KU( pk(~key) ) @ #vk ) )
            case Get_pk
            MIRRORED
          next
            case c_pk
            step( solve( !KU( ~key ) @ #vk.1 ) )
              case attackerkey
              MIRRORED
            qed
          qed
        qed
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      step( solve( (#vl, 0) ~~> (#i, 1) ) )
        case aenc
        by step( solve( !Pk( $A, ~key ) ▶₁ #vr ) )
      qed
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        step( solve( (#vl, 0) ~~> (#i, 1) ) )
          case Var_fresh_key
          step( solve( !KU( ~key ) @ #vk ) )
            case attackerkey
            MIRRORED
          qed
        qed
      qed
    qed
  next
    case RHS
    step( simplify )
    step( solve( !KD( x ) ▶₁ #i ) )
      case Attacker_make_message
      step( solve( (#vl, 0) ~~> (#i, 1) ) )
        case d_0_fst
        step( solve( (#vr.1, 0) ~~> (#i, 1) ) )
          case Var_pub_B
          step( solve( !KU( $B ) @ #vk ) )
            case coerce
            step( solve( !KD( $B ) ▶₀ #vk ) )
              case Attacker_make_message
              by step( contradiction /* impossible chain */ )
            next
              case Encrypt_Attacker
              by step( contradiction /* impossible chain */ )
            next
              case Get_pk
              step( solve( !Pk( S, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            next
              case Ow_Secrecy
              by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr.2 ) )
            next
              case Sender_encrypt
              by step( contradiction /* impossible chain */ )
            next
              case attackerkey
              step( solve( !Sk( $B.1, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case pub
            MIRRORED
          qed
        qed
      next
        case d_0_snd
        step( solve( (#vr.1, 0) ~~> (#i, 1) ) )
          case Var_fresh_n
          step( solve( !KU( ~n ) @ #vk ) )
            case Attacker_make_message
            MIRRORED
          qed
        qed
      next
        case pair
        step( solve( !KU( ~n ) @ #vk.2 ) )
          case Attacker_make_message
          step( solve( !KU( $B ) @ #vk.2 ) )
            case coerce
            step( solve( !KD( $B ) ▶₀ #vk.2 ) )
              case Attacker_make_message
              by step( contradiction /* impossible chain */ )
            next
              case Encrypt_Attacker
              by step( contradiction /* impossible chain */ )
            next
              case Get_pk
              step( solve( !Pk( S, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            next
              case Ow_Secrecy
              by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr.2 ) )
            next
              case Sender_encrypt
              by step( contradiction /* impossible chain */ )
            next
              case attackerkey
              step( solve( !Sk( $B.1, t ) ▶₀ #vr.2 ) )
                case Setup
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case pub
            MIRRORED
          qed
        qed
      qed
    next
      case Encrypt_Attacker
      step( solve( (#vl, 0) ~~> (#i, 1) ) )
        case aenc
        by step( solve( !Pk( $A, ~key ) ▶₀ #vr ) )
      qed
    next
      case Get_pk
      step( solve( !Pk( S, t ) ▶₀ #vr ) )
        case Setup
        step( solve( (#vl, 0) ~~> (#i, 1) ) )
          case pk
          step( solve( !KU( pk(~key) ) @ #vk ) )
            case Get_pk
            MIRRORED
          next
            case c_pk
            step( solve( !KU( ~key ) @ #vk.1 ) )
              case attackerkey
              MIRRORED
            qed
          qed
        qed
      qed
    next
      case Ow_Secrecy
      by step( solve( St_ReceiveKey_Oracle_plain( t, key_ ) ▶₀ #vr ) )
    next
      case Sender_encrypt
      step( solve( (#vl, 0) ~~> (#i, 1) ) )
        case aenc
        by step( solve( !Pk( $A, ~key ) ▶₁ #vr ) )
      qed
    next
      case attackerkey
      step( solve( !Sk( $B, t ) ▶₀ #vr ) )
        case Setup
        step( solve( (#vl, 0) ~~> (#i, 1) ) )
          case Var_fresh_key
          step( solve( !KU( ~key ) @ #vk ) )
            case attackerkey
            MIRRORED
          qed
        qed
      qed
    qed
  qed
next
  case Rule_Get_pk
  backward-search
    case LHS
    step( simplify )
    MIRRORED
  next
    case RHS
    step( simplify )
    MIRRORED
  qed
next
  case Rule_Ow_Secrecy
  backward-search
    case LHS
    step( simplify )
    by step( solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i ) )
  next
    case RHS
    step( simplify )
    by step( solve( St_ReceiveKey_Oracle_plain( m_, key_ ) ▶₀ #i ) )
  qed
next
  case Rule_Send
  backward-search
    case LHS
    step( simplify )
    MIRRORED
  next
    case RHS
    step( simplify )
    MIRRORED
  qed
next
  case Rule_Sender_encrypt
  backward-search
    case LHS
    step( simplify )
    by step( solve( !Pk( $A, ~key ) ▶₁ #i ) )
  next
    case RHS
    step( simplify )
    by step( solve( !Pk( $A, ~key ) ▶₁ #i ) )
  qed
next
  case Rule_Setup
  backward-search
    case LHS
    step( simplify )
    MIRRORED
  next
    case RHS
    step( simplify )
    MIRRORED
  qed
next
  case Rule_attackerkey
  backward-search
    case LHS
    step( simplify )
    step( solve( !Sk( $B, key ) ▶₀ #i ) )
      case Setup
      MIRRORED
    qed
  next
    case RHS
    step( simplify )
    step( solve( !Sk( $B, key ) ▶₀ #i ) )
      case Setup
      MIRRORED
    qed
  qed
qed

/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: code2.spthy

  processing time: 0.56s
  
  RHS :  ow_value_notequal (all-traces): verified (4 steps)
  LHS :  ow_value_notequal (all-traces): verified (4 steps)
  RHS :  secret_sender_message (all-traces): verified (4 steps)
  LHS :  secret_sender_message (all-traces): verified (4 steps)
  RHS :  ow_m_secret (all-traces): verified (2 steps)
  LHS :  ow_m_secret (all-traces): verified (2 steps)
  DiffLemma:  Observational_equivalence : verified (209 steps)

==============================================================================
